# Elixir School

## Basics

[Elixir School Basics](https://elixirschool.com/en/lessons/basics/basics)

<!-- livebook:{"break_markdown":true} -->

### Atoms

A constant whose name is its value

`:foo`

Equivalents:

* JavaScript `const s = Symbol("foo")`
* Ruby `:foo`

```elixir
:foo
```

```elixir
:foo == :bar
```

Booleans `true` and `false` are also atoms `:true` and `:false`

```elixir
[is_atom(true), is_atom(false), is_boolean(true), is_boolean(false)]
```

Module names are also valid atoms

<!-- livebook:{"break_markdown":true} -->

### Boolean Operators

`||`, `&&`, `!`, `and`, `or`, `not` are the built-in boolean operators

```elixir
-20 || true
```

```elixir
42 && true
```

```elixir
!42
```

Operators `and`, `or`, `not` must have a boolean as their first argument

```elixir
true and 42
```

```elixir
42 and true
```

```elixir
not false
```

### String Interpolation and Concatenation

```elixir
first_name = "Charles"
middle_name = "Thomas"
last_name = "Roth"
full_name = "#{first_name} #{middle_name}" <> " #{last_name}" <> " III"
```

## Collections

### List

Collections of values which may include multiple types and non-unique values

Implemented as linked lists therefore prepend is `O(1)` and append is `O(n)`

```elixir
list = [3.14, :pie, "Apple"]
```

```elixir
# prepend (fast)
["π" | list]
```

```elixir
# append (slow), concatenation
list ++ ["π"]
```

```elixir
# list subtraction
list -- ["Apple"]
```

```elixir
# head & tail
[head | tail] = list
h = hd(list)
t = tl(list)
[h, t] == [head, tail]
```

### Tuples

Similar to `List`

* Stored contiguously in memory
* Modification is expensive (new tuple is copied to memory)

Very useful in "pattern matching"

```elixir
tup_list = {3.14, :pie, "Apple"}
```

### Keyword List

* Two-element tuple whose first element is an atom
* Keys are atoms, ordered and do not have to be unique

```elixir
[first_name: "Charlie", last_name: "Roth"]
```

```elixir
[{:first_name, "Charlie"}, {:last_name, "Roth"}]
```

### Maps

* key-value store
* Keys can be of any type
* Un-ordered

```elixir
person = %{:first_name => "Charlie", :last_name => "Roth", :age => 26}
```

```elixir
person[:first_name]
```

A `Map` can be updated with "map update" syntax

```elixir
%{person | :first_name => "Charles"}
```

When modifying a map, with "map update" syntax, only keys that are present are allowed to be updated

```elixir
%{person | :location => "Sweden"}
```

To add keys that are not currently in the `Map`, use the `Map.put/3` function

```elixir
Map.put(person, :location, "Sweden")
```

## Enum

[`Enum` module](https://hexdocs.pm/elixir/Enum.html) includes 70 functions to work with enumerables (`Map`, `List`, `Keyword List`)

_Lazy enumeration_ can be achieved with the `Stream` module

```elixir
Enum.all?(["foo", "bar", "hello"], fn s -> String.length(s) == 3 end)
```

```elixir
Enum.any?(["foo", "bar", "hello"], fn s -> String.contains?(s, "oo") end)
```

```elixir
Enum.each(["one", "two", "three"], fn s -> IO.puts(s) end)
```

```elixir
Enum.map([1, 2, 3], fn n -> n * 2 end)
```

```elixir
Enum.filter([0, 1, 2, 3, 4, 5], fn n -> rem(n, 2) == 0 end)
```

```elixir
Enum.reduce([1, 2, 3, 4, 5], 0, fn n, acc -> acc + n end)
```

```elixir
Enum.reduce(["3", "2", "1", "Lift Off!!"], "", fn s, acc -> acc <> " " <> s end)
```

```elixir
Enum.sort([4, 2, 5, 3, 1])
```

```elixir
Enum.sort([4, 2, 5, 3, 1], :desc)
```

The "Capture Operator" `&` can be used to represent an anonymous function

Arguments supplied to the anonymous function can be accessed through `&1 ... &n` where `n` represents the order of the arguments

```elixir
Enum.reduce(["3", "2", "1", "Lift Off!!"], "", &(&2 <> " " <> &1))
```

## Pattern Matching

Allows matching of simple values, data structures and functions

<!-- livebook:{"break_markdown":true} -->

### Match Operator

In Elixir, the `=` sign is not the same as most programming languages. The `=` sign is actually an operator called the _match operator_. Behaves as an algebraic `=` sign and when the match is successful, it behaves as assignment.

The `=` turns the expression into an equation where the LHS must _match_ the RHS. If the match succeeds, it returns the value of the equation

```elixir
x = 1
```

```elixir
1 = x
```

```elixir
2 = x
```

```elixir
list = [1, 2, 3]
```

```elixir
[1, 2, 3] = list
```

```elixir
[2, 3, 4] = list
```

```elixir
[1 | tail] = list
```

```elixir
{:ok, value} = {:ok, "Success"}
```

```elixir
{:ok, value} = {:error, "Failed to read file"}
```

### Pin Operator

The `^` operator matches on the existing value rather than rebinding to a new one

Keys in `Map`s and function clasues can use the `^` operator as well

```elixir
x = 1
```

```elixir
^x = 2
```

```elixir
{x, ^x} = {2, 1}
```

```elixir
x
```

```elixir
key = "hello"
%{^key => "world"} = %{"hello" => "world"}
```

```elixir
greeting = "Hello"

greet = fn
  ^greeting, name -> "Hi #{name}"
  greeting, name -> "#{greeting}, #{name}"
end
```

```elixir
greet.("Hello", "Charlie")
```

```elixir
greet.("God morgon", "Charlie")
```

## Control Structures

Control structures in Elixir are implemented as functions such as `if/2` where the first argument is the conditional to evaluate and the second argument is the continuation function. However, in practice they are used as macros and not the typical language constructs like in most programming languages.

Available control structures:

* `if/2`
* `unless/2`
* `case/2`
* `cond/1`
* `with/1`

```elixir
if String.valid?("Hello") do
  "Valid string :)"
else
  "Invalid string :("
end
```

```elixir
unless is_integer(123) do
  "Not an integer"
end
```

`case/2` is the same as Rust's `match` operator

```elixir
case {:ok, "Hello world"} do
  {:ok, msg} -> msg
  {:error} -> "Oops"
  _ -> "idk what is going on"
end
```

```elixir
case {1, 2, 3} do
  {1, x, 3} when rem(x, 2) == 0 ->
    "Matched"

  _ ->
    "Second number is odd"
end
```

The `with/2` function is useful when you want to perform something similar to nested `case/2` functions but desire a more composable way to write these conditions

```elixir
person = %{first: "Charles", last: "Roth"}

with {:ok, first} <- Map.fetch(person, :first),
     {:ok, last} <- Map.fetch(person, :last),
     do: last <> ", " <> first
```

```elixir
person = %{first: "Charles"}

with {:ok, first} <- Map.fetch(person, :first),
     {:ok, last} <- Map.fetch(person, :last),
     do: last <> ", " <> first
```

## Functions

### Anonymous Functions

```elixir
adder = fn a, b -> a + b end
adder.(2, 3)
```

```elixir
adder_short = &(&1 + &2)
adder_short.(4, 5)
```

Pattern matching can be used with function signatures as well

```elixir
handle_result = fn
  {:ok, result} -> IO.puts("Handling...")
  {:ok, _} -> IO.puts("Handling some other stuff...")
  {:error} -> IO.puts("Error occurred")
end
```

```elixir
some_result = 42
```

```elixir
handle_result.({:ok, some_result})
```

```elixir
handle_result.({:error})
```

### Named Functions

```elixir
defmodule Greeter do
  def greet(name) do
    "Hey, " <> name
  end

  def goodbye(name), do: "Good bye, " <> name
end
```

```elixir
Greeter.greet("Charlie")
```

```elixir
Greeter.goodbye("Charlie")
```

Functions have an _arity_, such as `case/2`, where `/2` represents the number arguments the function accepts

This allows you to have several functions with the same name but with a different number of arguments

```elixir
defmodule Greeter2 do
  def hello(), do: "Hello, anon"
  def hello(name), do: "Hello, " <> name
  def hello(name1, name2), do: "Hello, " <> name1 <> " and " <> name2
end
```

```elixir
IO.puts(Greeter2.hello())
IO.puts(Greeter2.hello("Charlie"))
IO.puts(Greeter2.hello("Charlie", "eilrahC"))
```

Multiple functions with the same name but different arities is actually an example of pattern matching, a simple one that is. Pattern matching in function signatures can be more powerful than just the number of arguments, they can be matched by the contents of the arguments themselves

```elixir
defmodule Greeter1 do
  def hello(%{name: person_name}) do
    IO.puts("Hello, " <> person_name)
  end

  def full_hello(%{name: person_name} = person) do
    IO.puts("Hello, " <> person_name)
    IO.inspect(person)
  end
end
```

Here the function `Greeter1.hello/1` takes a `Map` as its argument. We then _destructure_ this `Map` and extract the value at the key `:name` and assign that to the variable `person_name`. This assignment only happens if the function signature match is correct, else the result is an error

```elixir
Greeter1.hello(%{name: "Charlie Roth"})
Greeter1.hello(%{name: "Miranda Nichols"})
# partial pattern match of the passed Map
Greeter1.hello(%{name: "Parker Roth", location: "Arizona", age: 21})
```

```elixir
Greeter1.hello("Charlie Roth")
```

```elixir
Greeter1.full_hello(%{name: "Parker Roth", location: "Arizona", age: 21})
```

### Guards

Functions can have "attached" _guard_ statements that will be checked after the function signature is matched

This allows you to have even more granular matching on which function to execute

```elixir
defmodule Greeter3 do
  def hello(names) when is_list(names) do
    names |> Enum.join(", ") |> hello
  end

  def hello(name) when is_binary(name) do
    phrase() <> name
  end

  defp phrase, do: "Hello "
end
```

```elixir
Greeter3.hello(["Charlie", "Miranda", "Parker"])
```

Function signatures can have default values for arguments when they are not supplied to the function

```elixir
defmodule Greeter4 do
  def hello(name, lang \\ "en") do
    phrase(lang) <> name
  end

  defp phrase("en"), do: "Hello, "
  defp phrase("es"), do: "Hola, "
end
```

```elixir
IO.puts(Greeter4.hello("Charlie"))
IO.puts(Greeter4.hello("Charlie", "es"))
```
